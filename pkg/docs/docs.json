{
  "sections": {
    "command-reference": {
      "title": "Command Reference",
      "content": "This document provides a comprehensive reference for all `docgen` commands, organized by function.",
      "subsections": [
        {
          "title": "Core Commands",
          "content": "These commands form the primary workflow for initializing, generating, and managing documentation.\n\n### docgen init\n\nInitializes a new documentation generation configuration for the current project.\n\n-   **Usage**: `docgen init [flags]`\n-   **Description**: Creates a `docs/` directory with a default `docgen.config.yml` file and a set of starter prompt files in `docs/prompts/`. This command sets up the necessary structure to begin generating documentation. It will not overwrite existing files.\n-   **Flags**:\n\n| Flag | Description | Default |\n| :--- | :--- | :--- |\n| `--type` | The type of project to initialize. Currently, only `library` is supported. | `library` |\n| `--model` | The default LLM model to use for generation (e.g., `gemini-1.5-flash-latest`). | (none) |\n| `--regeneration-mode` | The regeneration mode: `scratch` or `reference`. | (none) |\n| `--rules-file` | The name of the rules file for context generation (e.g., `docs.rules`). | (none) |\n| `--structured-output-file` | The path for the structured JSON output file. | (none) |\n| `--system-prompt` | The system prompt to use: `default` or a path to a custom file. | (none) |\n| `--output-dir` | The output directory for generated documentation. | (none) |\n\n-   **Examples**:\n    ```bash\n    # Initialize with default settings\n    docgen init\n\n    # Initialize and specify a default model and rules file\n    docgen init --model gemini-2.5-pro --rules-file docs.rules\n    ```\n\n---\n\n### docgen generate\n\nGenerates documentation for the current package based on its configuration.\n\n-   **Usage**: `docgen generate [flags]`\n-   **Description**: Reads the `docs/docgen.config.yml` file, builds the necessary context using `grove-context`, calls an LLM for each configured section, and writes the generated Markdown files to the specified output directory.\n-   **Flags**:\n\n| Flag | Shorthand | Description |\n| :--- | :--- | :--- |\n| `--section` | `-s` | Generate only the specified sections by name. Can be used multiple times. |\n\n-   **Examples**:\n    ```bash\n    # Generate all documentation sections defined in the config\n    docgen generate\n\n    # Generate only the 'overview' section\n    docgen generate --section overview\n\n    # Generate the 'overview' and 'examples' sections\n    docgen generate -s overview -s examples\n    ```\n\n---\n\n### docgen aggregate\n\nDiscovers all `docgen`-enabled packages in a workspace and aggregates their documentation into a single output directory.\n\n-   **Usage**: `docgen aggregate [flags]`\n-   **Description**: This command is designed for monorepos. It scans the workspace for packages with an enabled `docgen.config.yml`, copies their final documentation into a unified directory, and creates a `manifest.json` file that describes all the collected documentation, which is useful for static site generators.\n-   **Flags**:\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--output-dir` | `-o` | The directory to save the aggregated documentation. | `dist` |\n\n-   **Examples**:\n    ```bash\n    # Aggregate documentation from all workspace packages into the ./dist directory\n    docgen aggregate\n\n    # Specify a different output directory\n    docgen aggregate --output-dir ./public/docs\n    ```\n\n---\n\n### docgen sync-readme\n\nGenerates the `README.md` from a template and a source documentation file.\n\n-   **Usage**: `docgen sync-readme [flags]`\n-   **Description**: Synchronizes the project's `README.md` based on the `readme` configuration in `docs/docgen.config.yml`. It reads a template file, injects a specified documentation section into it, and writes the result to the output `README.md` file.\n-   **Flags**:\n\n| Flag | Description |\n| :--- | :--- |\n| `--generate-source` | Generate the source documentation section before syncing the README. |\n\n-   **Examples**:\n    ```bash\n    # Sync the README using the existing documentation\n    docgen sync-readme\n\n    # Regenerate the overview section first, then sync the README\n    docgen sync-readme --generate-source\n    ```\n\n---"
        },
        {
          "title": "Advanced Commands",
          "content": "These commands provide more specialized functionality for customization and maintenance.\n\n### docgen customize\n\nCreates a `grove-flow` plan for interactively customizing and generating documentation.\n\n-   **Usage**: `docgen customize [flags]`\n-   **Description**: This command bridges `docgen` with `grove-flow` to create a guided, interactive workflow for documentation generation. It reads your `docgen.config.yml`, creates a new `grove-flow` plan, and passes your configuration to the plan as variables. This allows you to use AI agents or structured prompts to refine your documentation before final generation.\n-   **Prerequisites**: The `flow` command must be installed and available in your `PATH`.\n-   **Flags**:\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--recipe-type` | `-r` | The recipe to use: `agent` for an interactive AI agent, or `prompts` for a structured prompt-based flow. | `agent` |\n\n-   **Examples**:\n    ```bash\n    # Create a customization plan using the default 'agent' recipe\n    docgen customize\n\n    # Create a plan using the 'prompts' recipe\n    docgen customize --recipe-type prompts\n\n    # After creating the plan, run it with grove-flow\n    flow plan run\n    ```\n\n---\n\n### docgen regen-json\n\nRegenerates the structured JSON output from existing Markdown files.\n\n-   **Usage**: `docgen regen-json`\n-   **Description**: If you have configured a `structured_output_file` in your `docgen.config.yml`, this command will re-parse your existing generated Markdown files and update the JSON output. It does not call any LLMs or modify the Markdown files, making it a fast way to update the structured data if you've made manual edits or if the parsing logic has changed.\n-   **Arguments**: None\n-   **Flags**: None\n-   **Examples**:\n    ```bash\n    # Regenerate the JSON output based on the current state of the markdown files\n    docgen regen-json\n    ```\n\n---\n\n### docgen recipe\n\nManages and displays documentation recipes for use with `grove-flow`.\n\n-   **Usage**: `docgen recipe [subcommand]`\n-   **Description**: This is a parent command for working with `docgen` recipes.\n-   **Subcommands**:\n    -   **`print`**: Prints all available `docgen` recipes in a JSON format that is consumable by `grove-flow`. This is used internally by the `docgen customize` command.\n        -   **Usage**: `docgen recipe print`\n        -   **Example**:\n            ```bash\n            # Print available recipes to stdout\n            docgen recipe print\n            ```\n\n---"
        },
        {
          "title": "Utility Commands",
          "content": "### docgen version\n\nPrints the version information for the `docgen` binary.\n\n-   **Usage**: `docgen version [flags]`\n-   **Description**: Displays the version, commit hash, and build date of the installed `docgen` command.\n-   **Flags**:\n\n| Flag | Description |\n| :--- | :--- |\n| `--json` | Output the version information in JSON format. |\n\n-   **Examples**:\n    ```bash\n    # Display version information in a human-readable format\n    docgen version\n\n    # Get version information as JSON for scripting\n    docgen version --json\n    ```"
        }
      ]
    },
    "configuration": {
      "title": "Configuration",
      "content": "The `docs/docgen.config.yml` file is the central control panel for `grove-docgen`. It defines everything from the high-level properties of your documentation to the specific models, prompts, and context used for generating each section.",
      "subsections": [
        {
          "title": "File Structure Overview",
          "content": "A typical `docgen.config.yml` file is organized into root-level metadata, a `settings` block for global configuration, a `sections` array defining each document to be generated, and a `readme` block for synchronizing the main `README.md`.",
          "code_blocks": [
            "# yaml-language-server: $schema=https://raw.githubusercontent.com/mattsolo1/grove-docgen/main/schema/docgen.config.schema.json\n\n# Root-level metadata for the documentation package.\nenabled: true\ntitle: \"Grove Context\"\ndescription: \"A rule-based tool for managing file-based context for LLMs.\"\ncategory: \"Developer Tools\"\n\n# Global settings that apply to all sections unless overridden.\nsettings:\n  model: gemini-2.5-pro\n  regeneration_mode: reference\n  rules_file: docs.rules\n  output_dir: docs\n  structured_output_file: pkg/docs/docs.json\n  system_prompt: default\n  \n  # Global generation parameters\n  temperature: 0.7\n  top_p: 0.9\n\n# An array defining each documentation file to be generated.\nsections:\n  - name: overview\n    order: 1\n    title: Overview\n    prompt: prompts/01-overview.md\n    output: 01-overview.md\n    json_key: introduction\n    \n    # Per-section override for the model\n    model: gemini-2.0-flash-latest\n    \n    # Per-section override for generation parameters\n    max_output_tokens: 4096\n\n# Configuration for synchronizing the project's main README.md.\nreadme:\n  generate_toc: true\n  template: docs/README.md.tpl\n  output: README.md\n  source_section: overview\n  strip_lines: 2"
          ]
        },
        {
          "title": "Root-Level Fields",
          "content": "These fields define the overall properties of your documentation package, primarily used by the `docgen aggregate` command.\n\n| Field         | Type    | Description                                                                                             |\n| :------------ | :------ | :------------------------------------------------------------------------------------------------------ |\n| `enabled`     | boolean | If `false`, the `docgen aggregate` command will skip this package. Defaults to `true`.                  |\n| `title`       | string  | The primary title of the documentation set (e.g., \"Grove Flow\").                                        |\n| `description` | string  | A brief, one-sentence description of the project.                                                       |\n| `category`    | string  | A category used to group related packages in an aggregated documentation site (e.g., \"Developer Tools\"). |"
        },
        {
          "title": "The `settings` Section",
          "content": "This section contains global configurations that apply to all documentation sections unless overridden at the section level.\n\n| Field                    | Type   | Description                                                                                                                                                                                          |\n| :----------------------- | :----- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| `model`                  | string | The default LLM model to use for generation (e.g., `gemini-2.5-pro`, `gpt-4o`).                                                                                                                        |\n| `regeneration_mode`      | string | Determines regeneration behavior. `scratch` generates from scratch. `reference` provides the existing document to the LLM as context for updates.                                                      |\n| `rules_file`             | string | Path to the `grove-context` rules file (relative to the `docs/` directory) that defines the codebase context for the LLM.                                                                              |\n| `structured_output_file` | string | (Optional) Path to a file where structured JSON output will be saved after parsing the generated Markdown.                                                                                             |\n| `system_prompt`          | string | Can be set to `default` to use the built-in system prompt, or a path to a custom prompt file (relative to `docs/`).                                                                                    |\n| `output_dir`             | string | The directory where generated documentation files will be saved, relative to the project root. Defaults to `docs`.                                                                                     |\n\n### Global Generation Parameters\n\nYou can set default LLM generation parameters within the `settings` block. These will be applied to every section unless a section provides its own override.\n\n-   `temperature` (float, 0.0-1.0): Controls randomness. Higher values produce more creative but less predictable output.\n-   `top_p` (float): Nucleus sampling parameter.\n-   `top_k` (integer): Top-k sampling parameter.\n-   `max_output_tokens` (integer): The maximum number of tokens to generate for each section."
        },
        {
          "title": "The `sections` Array",
          "content": "This is a list where each item represents a single Markdown file to be generated. The order of generation is determined by the `order` field.\n\n| Field   | Type   | Description                                                                                             |\n| :------ | :----- | :------------------------------------------------------------------------------------------------------ |\n| `name`  | string | A unique, internal identifier for the section (e.g., `overview`, `command-reference`).                  |\n| `title` | string | The user-facing title for the section, often used as the H1 heading (e.g., \"Command Reference\").        |\n| `order` | integer| A number that determines the sorting order of sections in the final aggregated manifest.                |\n| `prompt`| string | The path to the Markdown prompt file for this section, relative to the `docs/` directory.               |\n| `output`| string | The path where the generated Markdown file will be saved, relative to the `output_dir` setting.         |\n| `json_key`| string | (Optional) A key used to identify this section's content when generating a structured JSON output file. |\n\n### Per-Section Overrides\n\nYou can override the global `model` and any generation parameters on a per-section basis. This is useful for tasks that require different models or more constrained outputs.",
          "code_blocks": [
            "sections:\n  - name: overview\n    title: Overview\n    # ...\n    # This section uses the global model and settings.\n\n  - name: command-reference\n    title: Command Reference\n    # ...\n    # This section uses a smaller, faster model and has a higher token limit.\n    model: gemini-2.0-flash-latest\n    max_output_tokens: 8192"
          ]
        },
        {
          "title": "The `readme` Section",
          "content": "This section configures the `docgen sync-readme` command, which generates the project's main `README.md` from a template.\n\n| Field           | Type    | Description                                                                                                |\n| :-------------- | :------ | :--------------------------------------------------------------------------------------------------------- |\n| `template`      | string  | Path to the README template file (e.g., `docs/README.md.tpl`).                                             |\n| `output`        | string  | Path to the final output `README.md` file.                                                                 |\n| `source_section`| string  | The `name` of the section from the `sections` array whose content will be injected into the template.        |\n| `strip_lines`   | integer | (Optional) Number of lines to remove from the top of the `source_section` content before injection.        |\n| `generate_toc`  | boolean | (Optional) If `true`, a table of contents linking to all documentation files will be injected.             |"
        },
        {
          "title": "Advanced Topics",
          "content": "### Context Management with `rules_file`\n\nThe `rules_file` setting is a key integration point with `grove-context` (`cx`). The file specified here uses a `.gitignore`-style syntax to define which source code files from your project are collected and provided to the LLM as context. A well-defined rules file is critical for generating accurate, code-aware documentation.\n\n### JSON Schema Validation\n\nThe `docgen.config.yml` file can be validated against a JSON schema. Including the schema line at the top of your file enables autocompletion and validation in compatible editors like VS Code, helping you avoid configuration errors.\n\n\n### Configuration Inheritance\n\nSettings are applied with a clear order of precedence, allowing for fine-grained control:\n1.  **Section-level**: A `model` or generation parameter (e.g., `temperature`) set directly within a `sections` item has the highest priority.\n2.  **Global `settings`**: If not defined at the section level, the value from the main `settings` block is used.\n3.  **Application Defaults**: If a setting is not found in the configuration, a hardcoded default within `grove-docgen` may be used.",
          "code_blocks": [
            "# yaml-language-server: $schema=https://raw.githubusercontent.com/mattsolo1/grove-docgen/main/schema/docgen.config.schema.json"
          ]
        }
      ]
    },
    "examples": {
      "title": "Examples",
      "content": "This guide provides practical examples of using `grove-docgen` in common development workflows, from initializing a new project to using `grove-flow` for interactive documentation generation.",
      "subsections": [
        {
          "title": "Example 1: Basic Project Setup",
          "content": "This example covers the fundamental workflow for a new project: initializing the configuration, customizing a prompt, and generating the documentation.\n\nAssume you have a Go project and want to generate its initial documentation.\n\n#### 1. Initialize `docgen`\n\nRun the `docgen init` command in the project root. This command scaffolds the necessary configuration and prompt files.\n\n\nThis creates the following structure:\n\n\nThe `docs/docgen.config.yml` file is pre-filled with sections for an overview, examples, and more, all configured to use the model and rules file specified.\n\n#### 2. Customize a Prompt\n\nThe generated files in `docs/prompts/` are templates that can be modified. Edit the overview prompt to be more specific to the project.\n\nOpen `docs/prompts/01-overview.md` and add details about the project's features and purpose.\n\n**`docs/prompts/01-overview.md` (modified):**\n\n#### 3. Define the Context\n\nEdit the `docs/docs.rules` file to specify which source code files are relevant for generating the documentation. `grove-context` will use these rules.\n\n**`docs/docs.rules`:**\n\n#### 4. Generate the Documentation\n\nRun the `docgen generate` command. It reads the configuration, uses `grove-context` to build the context from the rules, and calls the LLM for each section defined in `docgen.config.yml`.\n\n\n**Expected Output:**\n\nThe command generates Markdown files in the `docs/` directory, one for each section.\n\n\nThis process produces a documentation set based on the source code and custom prompts.",
          "code_blocks": [
            "docgen init --model gemini-2.5-pro --rules-file docs.rules",
            "my-go-app/\n├── docs/\n│   ├── docgen.config.yml  # Main configuration\n│   ├── docs.rules         # Context rules for 'grove-context'\n│   └── prompts/\n│       ├── 01-overview.md\n│       ├── 02-examples.md\n│       └── ... (other prompt templates)\n└── ... (your source code)",
            "# Documentation Task: Project Overview\n\nYou are a technical writer. Write a single-page overview for the `my-go-app` tool.\n\n## Task\nBased on the provided codebase context, create an overview that describes these specific features:\n- A caching layer.\n- A configuration file format.\n- Integration with Prometheus for metrics.",
            "# Include all Go files, but exclude tests\n**/*.go\n!**/*_test.go\n\n# Include the main README\nREADME.md",
            "docgen generate",
            "my-go-app/\n└── docs/\n    ├── 01-overview.md         # Generated documentation\n    ├── 02-examples.md         # Generated documentation\n    ├── ...\n    ├── docgen.config.yml\n    ├── docs.rules\n    └── prompts/\n        └── ..."
          ]
        },
        {
          "title": "Example 2: Advanced Configuration for a Complex Project",
          "content": "This example demonstrates features for a larger project, such as using different models, controlling regeneration, and generating structured data.\n\n#### 1. Configure Advanced Settings\n\nModify `docgen.config.yml` for more granular control.\n\n-   **Section-Specific Model**: Use a different model for the overview than for the command reference.\n-   **Reference Mode**: Use `regeneration_mode: reference` to have the LLM improve existing documentation rather than writing it from scratch.\n-   **Structured Output**: Configure `structured_output_file` to generate a JSON file alongside the Markdown for programmatic use.\n\n**`docs/docgen.config.yml` (snippet):**\n\n#### 2. Generate a Single Section\n\nTo regenerate only one part of the documentation, use the `--section` flag.\n\n\nThis re-runs the LLM call only for the \"overview\" section.\n\n#### 3. Regenerate the Structured JSON\n\nAfter generating the Markdown, the structured JSON output can be updated without calling the LLM again. The `regen-json` command parses existing Markdown files and builds the JSON file.\n\n\nThis creates or updates `pkg/docs/docs.json` based on the content of the generated documentation, providing a machine-readable version of the docs.",
          "code_blocks": [
            "# yaml-language-server: $schema=...\ntitle: \"My Advanced Tool\"\ndescription: \"...\"\nenabled: true\nsettings:\n  model: gemini-2.0-flash  # Default to a fast model\n  regeneration_mode: reference\n  rules_file: docs.rules\n  structured_output_file: pkg/docs/docs.json\nsections:\n  - name: overview\n    order: 1\n    output: 01-overview.md\n    prompt: prompts/01-overview.md\n    title: Overview\n    model: gemini-2.5-pro # Override with a different model for this section\n  - name: command-reference\n    order: 2\n    output: 02-command-reference.md\n    prompt: prompts/02-command-reference.md\n    title: Command Reference\n    json_key: command_reference # Key for the structured JSON output",
            "docgen generate --section overview",
            "docgen regen-json"
          ]
        },
        {
          "title": "Example 3: Interactive Customization with Grove Flow",
          "content": "For projects where the documentation structure is not yet defined, `grove-docgen` integrates with `grove-flow` to interactively build the documentation plan with an AI agent.\n\n#### 1. Create a Customization Plan\n\nThe `docgen customize` command creates a `grove-flow` plan, which is a series of steps for an AI agent to follow.\n\n\nThis command inspects `docgen.config.yml` and creates a new plan in the `plans/` directory. The plan contains jobs for an AI agent to:\n1.  Review the project's source code.\n2.  Discuss the documentation structure.\n3.  Refine the prompt files for each section.\n4.  Run the `docgen generate` command to produce the documentation.\n\n#### 2. Run the Interactive Plan\n\nStart the workflow with `flow run`.\n\n\nThis command launches an interactive `tmux` session where an AI agent begins executing the plan.\n\n#### 3. Collaborate with the Agent\n\nInside the `tmux` session, you can provide instructions to the agent and review its work. This human-in-the-loop process allows for guiding the AI to create a documentation plan tailored to the project. Once the process is complete, the agent executes the final generation step.",
          "code_blocks": [
            "docgen customize --recipe-type agent",
            "# The plan name will be printed by the 'customize' command\nflow run plans/docgen-customize-agent-my-go-app"
          ]
        }
      ]
    },
    "overview": {
      "title": "Overview",
      "content": "`grove-docgen` is a command-line tool that generates technical documentation from a project's source code using LLMs and user-defined prompts. It provides a structured workflow for creating and maintaining documentation by defining it as a series of configurable sections.\n\n\u003c!-- placeholder for animated gif --\u003e\n\n### Key Features\n\n*   **Section-Based Architecture**: Defines documentation structure in a `docgen.config.yml` file. Each section is configured with its own prompt, output file, and LLM settings.\n*   **Customizable Prompts**: The `docgen init` command scaffolds a set of starter prompts in `docs/prompts/`. These files can be modified to fit the project's specific needs and documentation style.\n*   **Context-Aware Generation**: Uses `grove-context` to build file-based context from a `.grove/rules` file, providing the LLM with relevant source code to generate accurate documentation.\n*   **Interactive Customization**: The `docgen customize` command creates a `grove-flow` plan, enabling an interactive, agent-assisted workflow to refine documentation structure and content before generation.\n*   **Multi-Model Support**: A global default LLM model can be set in the configuration, with the option to override it for specific sections, allowing different models to be used for different tasks.\n*   **Workspace Aggregation**: The `docgen aggregate` command discovers all `docgen`-enabled packages within a workspace, generates their documentation, and collects the results into a single output directory with a `manifest.json`.\n*   **README Synchronization**: The `docgen sync-readme` command generates a project `README.md` from a template, injecting content from a specified documentation section to keep the overview consistent.",
      "subsections": [
        {
          "title": "How It Works",
          "content": "The documentation generation process follows a repeatable pipeline:\n1.  `grove-docgen` reads the `docs/docgen.config.yml` file to identify the defined documentation sections.\n2.  For each section, it calls `grove-context` (`cx`) to generate a file-based context based on the patterns in the configured `rules_file`.\n3.  It reads the content of the section's corresponding prompt file from the `docs/prompts/` directory.\n4.  It sends the generated context and the prompt to the configured LLM using the `grove llm request` command.\n5.  The LLM's response is processed and written to the section's specified output markdown file."
        },
        {
          "title": "Ecosystem Integration",
          "content": "`grove-docgen` functions as a component of the Grove tool suite and executes other tools in the ecosystem as subprocesses.\n\n*   **`grove-context` (`cx`)**: Provides the file-based context for all LLM requests, ensuring the model has an accurate understanding of the project's source code.\n*   **`grove-flow`**: The `docgen customize` command uses `grove-flow` to create and manage an interactive, plan-based workflow, turning documentation generation into a guided, agent-assisted process.\n*   **`grove-gemini` and `grove-openai`**: The `grove llm request` command is used to execute the calls to the configured LLM providers, handling the API interactions required to generate the documentation content."
        },
        {
          "title": "Installation",
          "content": "Install via the Grove meta-CLI:\n\nVerify installation:\n\nRequires the `grove` meta-CLI. See the [Grove Installation Guide](https://github.com/mattsolo1/grove-meta/blob/main/docs/02-installation.md) if you don't have it installed.",
          "code_blocks": [
            "grove install docgen",
            "docgen version"
          ]
        }
      ]
    }
  }
}