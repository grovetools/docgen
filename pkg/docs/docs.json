{
  "sections": {
    "command-reference": {
      "title": "Command Reference",
      "content": "This document provides a comprehensive reference for all `docgen` commands, organized by function.",
      "subsections": [
        {
          "title": "Core Commands",
          "content": "These commands form the primary workflow for initializing, generating, and managing documentation.\n\n### docgen init\n\nInitializes a new documentation generation configuration for the current project.\n\n-   **Usage**: `docgen init [flags]`\n-   **Description**: Creates a `docs/` directory with a default `docgen.config.yml` file and a set of starter prompt files in `docs/prompts/`. This command sets up the necessary structure to begin generating documentation. It will not overwrite existing files.\n-   **Flags**:\n\n| Flag | Description | Default |\n| :--- | :--- | :--- |\n| `--type` | The type of project to initialize. Currently, only `library` is supported. | `library` |\n| `--model` | The default LLM model to use for generation (e.g., `gemini-1.5-flash-latest`). | (none) |\n| `--regeneration-mode` | The regeneration mode: `scratch` or `reference`. | (none) |\n| `--rules-file` | The name of the rules file for context generation (e.g., `docs.rules`). | (none) |\n| `--structured-output-file` | The path for the structured JSON output file. | (none) |\n| `--system-prompt` | The system prompt to use: `default` or a path to a custom file. | (none) |\n| `--output-dir` | The output directory for generated documentation. | (none) |\n\n-   **Examples**:\n    ```bash\n    # Initialize with default settings\n    docgen init\n\n    # Initialize and specify a default model and rules file\n    docgen init --model gemini-2.5-pro --rules-file docs.rules\n    ```\n\n---\n\n### docgen generate\n\nGenerates documentation for the current package based on its configuration.\n\n-   **Usage**: `docgen generate [flags]`\n-   **Description**: Reads the `docs/docgen.config.yml` file, builds the necessary context using `grove-context`, calls an LLM for each configured section, and writes the generated Markdown files to the specified output directory.\n-   **Flags**:\n\n| Flag | Shorthand | Description |\n| :--- | :--- | :--- |\n| `--section` | `-s` | Generate only the specified sections by name. Can be used multiple times. |\n\n-   **Examples**:\n    ```bash\n    # Generate all documentation sections defined in the config\n    docgen generate\n\n    # Generate only the 'overview' section\n    docgen generate --section overview\n\n    # Generate the 'overview' and 'examples' sections\n    docgen generate -s overview -s examples\n    ```\n\n---\n\n### docgen aggregate\n\nDiscovers all `docgen`-enabled packages in a workspace and aggregates their documentation into a single output directory.\n\n-   **Usage**: `docgen aggregate [flags]`\n-   **Description**: This command is designed for monorepos. It scans the workspace for packages with an enabled `docgen.config.yml`, copies their final documentation into a unified directory, and creates a `manifest.json` file that describes all the collected documentation, which is useful for static site generators.\n-   **Flags**:\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--output-dir` | `-o` | The directory to save the aggregated documentation. | `dist` |\n\n-   **Examples**:\n    ```bash\n    # Aggregate documentation from all workspace packages into the ./dist directory\n    docgen aggregate\n\n    # Specify a different output directory\n    docgen aggregate --output-dir ./public/docs\n    ```\n\n---\n\n### docgen sync-readme\n\nGenerates the `README.md` from a template and a source documentation file.\n\n-   **Usage**: `docgen sync-readme [flags]`\n-   **Description**: Synchronizes the project's `README.md` based on the `readme` configuration in `docs/docgen.config.yml`. It reads a template file, injects a specified documentation section into it, and writes the result to the output `README.md` file.\n-   **Flags**:\n\n| Flag | Description |\n| :--- | :--- |\n| `--generate-source` | Generate the source documentation section before syncing the README. |\n\n-   **Examples**:\n    ```bash\n    # Sync the README using the existing documentation\n    docgen sync-readme\n\n    # Regenerate the overview section first, then sync the README\n    docgen sync-readme --generate-source\n    ```\n\n---"
        },
        {
          "title": "Advanced Commands",
          "content": "These commands provide more specialized functionality for customization and maintenance.\n\n### docgen customize\n\nCreates a `grove-flow` plan for interactively customizing and generating documentation.\n\n-   **Usage**: `docgen customize [flags]`\n-   **Description**: This command bridges `docgen` with `grove-flow` to create a guided, interactive workflow for documentation generation. It reads your `docgen.config.yml`, creates a new `grove-flow` plan, and passes your configuration to the plan as variables. This allows you to use AI agents or structured prompts to refine your documentation before final generation.\n-   **Prerequisites**: The `flow` command must be installed and available in your `PATH`.\n-   **Flags**:\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--recipe-type` | `-r` | The recipe to use: `agent` for an interactive AI agent, or `prompts` for a structured prompt-based flow. | `agent` |\n\n-   **Examples**:\n    ```bash\n    # Create a customization plan using the default 'agent' recipe\n    docgen customize\n\n    # Create a plan using the 'prompts' recipe\n    docgen customize --recipe-type prompts\n\n    # After creating the plan, run it with grove-flow\n    flow plan run\n    ```\n\n---\n\n### docgen regen-json\n\nRegenerates the structured JSON output from existing Markdown files.\n\n-   **Usage**: `docgen regen-json`\n-   **Description**: If you have configured a `structured_output_file` in your `docgen.config.yml`, this command will re-parse your existing generated Markdown files and update the JSON output. It does not call any LLMs or modify the Markdown files, making it a fast way to update the structured data if you've made manual edits or if the parsing logic has changed.\n-   **Arguments**: None\n-   **Flags**: None\n-   **Examples**:\n    ```bash\n    # Regenerate the JSON output based on the current state of the markdown files\n    docgen regen-json\n    ```\n\n---\n\n### docgen recipe\n\nManages and displays documentation recipes for use with `grove-flow`.\n\n-   **Usage**: `docgen recipe [subcommand]`\n-   **Description**: This is a parent command for working with `docgen` recipes.\n-   **Subcommands**:\n    -   **`print`**: Prints all available `docgen` recipes in a JSON format that is consumable by `grove-flow`. This is used internally by the `docgen customize` command.\n        -   **Usage**: `docgen recipe print`\n        -   **Example**:\n            ```bash\n            # Print available recipes to stdout\n            docgen recipe print\n            ```\n\n---"
        },
        {
          "title": "Utility Commands",
          "content": "### docgen version\n\nPrints the version information for the `docgen` binary.\n\n-   **Usage**: `docgen version [flags]`\n-   **Description**: Displays the version, commit hash, and build date of the installed `docgen` command.\n-   **Flags**:\n\n| Flag | Description |\n| :--- | :--- |\n| `--json` | Output the version information in JSON format. |\n\n-   **Examples**:\n    ```bash\n    # Display version information in a human-readable format\n    docgen version\n\n    # Get version information as JSON for scripting\n    docgen version --json\n    ```"
        }
      ]
    },
    "configuration": {
      "title": "Configuration",
      "content": "The `docs/docgen.config.yml` file is the central control panel for `grove-docgen`. It defines everything from the high-level properties of your documentation to the specific models, prompts, and context used for generating each section.",
      "subsections": [
        {
          "title": "File Structure Overview",
          "content": "A typical `docgen.config.yml` file is organized into root-level metadata, a `settings` block for global configuration, a `sections` array defining each document to be generated, and an optional `readme` block for synchronizing the main `README.md`.",
          "code_blocks": [
            "# yaml-language-server: $schema=https://raw.githubusercontent.com/mattsolo1/grove-docgen/main/schema/docgen.config.schema.json\n\n# Root-level metadata for the documentation package.\nenabled: true\ntitle: \"Grove Docgen\"\ndescription: \"LLM-powered, workspace-aware documentation generator.\"\ncategory: \"Developer Tools\"\n\n# Global settings that apply to all sections unless overridden.\nsettings:\n  model: gemini-1.5-flash-latest\n  regeneration_mode: reference\n  rules_file: docs.rules\n  output_dir: docs\n  structured_output_file: dist/docs.json\n  system_prompt: default\n  \n  # Global generation parameters\n  temperature: 0.7\n  top_p: 0.9\n\n# An array defining each documentation file to be generated.\nsections:\n  - name: overview\n    order: 1\n    title: Overview\n    prompt: prompts/01-overview.md\n    output: 01-overview.md\n    json_key: introduction\n    agg_strip_lines: 1 # Strip H1 heading during aggregation\n    \n    # Per-section override for the model\n    model: gemini-1.5-pro-latest\n    \n    # Per-section override for generation parameters\n    max_output_tokens: 4096\n\n  - name: config-schema\n    order: 2\n    title: Configuration Schema\n    type: schema_to_md\n    source: schema/docgen.config.schema.json\n    output: 02-config-schema.md\n\n# Configuration for synchronizing the project's main README.md.\nreadme:\n  generate_toc: true\n  template: docs/README.md.tpl\n  output: README.md\n  source_section: overview\n  strip_lines: 1"
          ]
        },
        {
          "title": "Root-Level Fields",
          "content": "These fields define the overall properties of your documentation package, primarily used by the `docgen aggregate` command to build a manifest for a documentation website.\n\n| Field | Type | Description |\n| :--- | :--- | :--- |\n| `enabled` | boolean | If `false`, the `docgen aggregate` command will skip this package. Defaults to `true`. |\n| `title` | string | The primary title of the documentation set (e.g., \"Grove Flow\"). |\n| `description` | string | A brief, one-sentence description of the project. |\n| `category` | string | A category used to group related packages in an aggregated documentation site (e.g., \"Developer Tools\"). |"
        },
        {
          "title": "The `settings` Section",
          "content": "This section contains global configurations that apply to all documentation sections unless overridden at the section level.\n\n| Field | Type | Description |\n| :--- | :--- | :--- |\n| `model` | string | The default LLM model to use for generation (e.g., `gemini-1.5-flash-latest`, `gpt-4o`). |\n| `regeneration_mode` | string | Determines regeneration behavior. `scratch` generates from scratch. `reference` provides the existing document to the LLM as context for updates. |\n| `rules_file` | string | Path to the `grove-context` rules file (relative to the `docs/` directory) that defines the codebase context for the LLM. |\n| `structured_output_file` | string | (Optional) Path to a file where structured JSON output will be saved after parsing the generated Markdown. |\n| `system_prompt` | string | Can be set to `default` to use the built-in system prompt, or a path to a custom prompt file (relative to `docs/`). |\n| `output_dir` | string | The directory where generated documentation files will be saved, relative to the project root. Defaults to `docs`. |\n\n### Global Generation Parameters\n\nYou can set default LLM generation parameters within the `settings` block. These will be applied to every section unless a section provides its own override.\n\n- `temperature` (float, 0.0-1.0): Controls randomness. Higher values produce more creative but less predictable output.\n- `top_p` (float): Nucleus sampling parameter.\n- `top_k` (integer): Top-k sampling parameter.\n- `max_output_tokens` (integer): The maximum number of tokens to generate for each section."
        },
        {
          "title": "The `sections` Array",
          "content": "This is a list where each item represents a single Markdown file to be generated. The order of generation is determined by the `order` field.\n\n| Field | Type | Description |\n| :--- | :--- | :--- |\n| `name` | string | A unique, internal identifier for the section (e.g., `overview`, `command-reference`). |\n| `title` | string | The user-facing title for the section, often used as the H1 heading (e.g., \"Command Reference\"). |\n| `order` | integer| A number that determines the sorting order of sections in the final aggregated manifest. |\n| `prompt`| string | The path to the Markdown prompt file for this section, relative to the `docs/` directory. Required unless `type` is specified. |\n| `output`| string | The path where the generated Markdown file will be saved, relative to the `output_dir` setting. |\n| `json_key`| string | (Optional) A key used to identify this section's content when generating a structured JSON output file. |\n| `type` | string | (Optional) Specifies a special generation type. Currently, only `schema_to_md` is supported. |\n| `source` | string | (Optional) The source file for a special `type`. For `schema_to_md`, this is the path to the JSON schema file. |\n| `agg_strip_lines` | integer | (Optional) Number of lines to remove from the top of the generated file during the `docgen aggregate` process. Useful for removing H1 titles. |\n\n### Per-Section Overrides\n\nYou can override the global `model` and any generation parameters on a per-section basis. This is useful for tasks that require different models or more constrained outputs.\n\n\n### Special Section Types\n\n#### `schema_to_md`\nThis type generates user-friendly Markdown documentation from a JSON schema file. It does not use a `prompt` file. Instead, it parses the `source` schema and uses a built-in prompt to ask the LLM to describe it.",
          "code_blocks": [
            "sections:\n  - name: overview\n    # ...\n    # This section uses the global model and settings.\n\n  - name: command-reference\n    # ...\n    # This section uses a more powerful model and has a higher token limit.\n    model: gemini-1.5-pro-latest\n    max_output_tokens: 8192",
            "sections:\n  - name: config-reference\n    title: Configuration Reference\n    order: 2\n    type: schema_to_md\n    source: schema/config.schema.json # Path to the JSON schema\n    output: 02-config-reference.md"
          ]
        },
        {
          "title": "The `readme` Section",
          "content": "This section configures the `docgen sync-readme` command, which generates the project's main `README.md` from a template.\n\n| Field | Type | Description |\n| :--- | :--- | :--- |\n| `template` | string | Path to the README template file (e.g., `docs/README.md.tpl`). |\n| `output` | string | Path to the final output `README.md` file. |\n| `source_section`| string | The `name` of the section from the `sections` array whose content will be injected into the template. |\n| `strip_lines` | integer | (Optional) Number of lines to remove from the top of the `source_section` content before injection. |\n| `generate_toc` | boolean | (Optional) If `true`, a table of contents linking to all documentation files will be injected. |"
        },
        {
          "title": "Advanced Topics",
          "content": "### Context Management with `rules_file`\n\nThe `rules_file` setting is a key integration point with `grove-context` (`cx`). The file specified here uses a `.gitignore`-style syntax to define which source code files from your project are collected and provided to the LLM as context. A well-defined rules file is critical for generating accurate, code-aware documentation.\n\n### JSON Schema Validation\n\nThe `docgen.config.yml` file can be validated against a JSON schema. Including the schema line at the top of your file enables autocompletion and validation in compatible editors like VS Code, helping you avoid configuration errors.\n\n\n### Configuration Precedence\n\nSettings are applied with a clear order of precedence, allowing for fine-grained control:\n1.  **Section-level**: A `model` or generation parameter (e.g., `temperature`) set directly within a `sections` item has the highest priority.\n2.  **Global `settings`**: If not defined at the section level, the value from the main `settings` block is used.\n3.  **Application Defaults**: If a setting is not found in the configuration, a hardcoded default within `grove-docgen` is used.",
          "code_blocks": [
            "# yaml-language-server: $schema=https://raw.githubusercontent.com/mattsolo1/grove-docgen/main/schema/docgen.config.schema.json"
          ]
        }
      ]
    },
    "examples": {
      "title": "Examples",
      "content": "Here are three practical examples for using `grove-docgen`, demonstrating increasing complexity from a basic setup to advanced configuration and full ecosystem integration.\n\n### Example 1: Basic Setup\n\nThis example covers initializing `grove-docgen` in a new project and generating a simple set of documentation.\n\n#### Configuration (`docs/docgen.config.yml`)\n\nFirst, run `docgen init` to create the initial configuration and prompt files. The resulting `docgen.config.yml` will look similar to this:\n\n\n#### Sample Prompts\n\nThe `docgen init` command creates starter prompts.\n\n**`docs/prompts/introduction.md`:**\n\n**`docs/prompts/usage.md`:**\n\n#### Commands\n\n1.  **Initialize Configuration:**\n    ```sh\n    docgen init\n    ```\n2.  **Generate Documentation:**\n    ```sh\n    docgen generate\n    ```\n    This command reads `docs/docgen.config.yml`, builds project context by running `grove cx generate` internally, sends each prompt to the LLM, and saves the results.\n\n#### Expected Output Structure\n\nAfter running the commands, your project will have the following structure:\n\n\n### Example 2: Advanced Configuration\n\nThis example demonstrates a more complex setup, including README synchronization, structured JSON output, and documentation generated from a JSON schema.\n\n#### Configuration (`docs/docgen.config.yml`)\n\nThis configuration adds a `readme` section, a `structured_output_file`, custom context rules, and a section for generating documentation from a schema.\n\n\n#### Supporting Files\n\n*   **`docs/docs.rules` (Context Rules):**\n    ```\n    # Include all source code\n    **/*.go\n    # Exclude tests\n    !**/*_test.go\n    # Include the schema file\n    schema/config.schema.json\n    ```\n*   **`schema/config.schema.json` (Source Schema):**\n    ```json\n    {\n      \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n      \"title\": \"Tool Configuration\",\n      \"description\": \"Configuration for the Advanced CLI Tool.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"port\": {\n          \"type\": \"integer\",\n          \"description\": \"The network port to listen on.\"\n        },\n        \"log_level\": {\n          \"type\": \"string\",\n          \"enum\": [\"debug\", \"info\", \"warn\", \"error\"]\n        }\n      }\n    }\n    ```\n*   **`docs/README.md.tpl` (README Template):**\n    ```markdown\n    # {{ .Title }}\n\n    {{ .Description }}\n\n    \u003c!-- DOCGEN:INTRODUCTION:START --\u003e\n    \u003c!-- Content will be injected here --\u003e\n    \u003c!-- DOCGEN:INTRODUCTION:END --\u003e\n\n    ## More Information\n\n    See the full documentation in the `docs/generated` directory.\n    ```\n\n#### Commands\n\n1.  **Generate all documentation sections:**\n    ```sh\n    docgen generate\n    ```\n2.  **Synchronize the README:**\n    ```sh\n    docgen sync-readme\n    ```\n3.  **(Optional) Regenerate JSON from Markdown:** If you manually edit the Markdown files, you can update the JSON without calling the LLM again.\n    ```sh\n    docgen regen-json\n    ```\n\n#### Expected Output Structure\n\nThe process generates documentation, a structured JSON file, and updates the root `README.md`.\n\n\n### Example 3: Grove Ecosystem Integration\n\nThis example shows how `grove-docgen` operates in a monorepo (or \"ecosystem\") with multiple packages, aggregating all documentation into a central directory for a website.\n\n#### Project Structure\n\n\n#### Configuration\n\n*   **`grove.yml` (Ecosystem Root):**\n    ```yaml\n    workspaces:\n      - \"packages/*\"\n    ```\n*   **`packages/tool-a/docs/docgen.config.yml`:**\n    ```yaml\n    enabled: true\n    title: Tool A\n    description: The first tool in the ecosystem.\n    category: Tools\n    # ... sections ...\n    ```\n*   **`packages/lib-b/docs/docgen.config.yml`:**\n    ```yaml\n    enabled: true\n    title: Library B\n    description: A shared library used by other tools.\n    category: Libraries\n    # ... sections ...\n    ```\n*   **`Makefile` (Ecosystem Root):**\n    ```makefile\n    .PHONY: docs\n\n    docs: generate-docs aggregate-docs\n\n    generate-docs:\n    \t@echo \"Generating documentation for all packages...\"\n    \tgrove ws foreach --no-private -- exec docgen generate\n\n    aggregate-docs:\n    \t@echo \"Aggregating all documentation...\"\n    \tdocgen aggregate -o dist\n    ```\n\n#### Commands\n\nFrom the ecosystem root, a single command can generate and aggregate all documentation.\n\n\nThis workflow performs two main actions:\n1.  `grove ws foreach ... exec docgen generate`: Runs `docgen generate` inside each package defined in `grove.yml`. This leverages `grove-context` to build context relevant to each specific package.\n2.  `docgen aggregate -o dist`: Scans all workspace packages, finds the generated documentation for those with `enabled: true`, copies the artifacts into the `dist` directory, and creates a `manifest.json`.\n\n#### Expected Output Structure\n\nThe `dist` directory contains all documentation, organized by package, with a manifest file that a static site generator can use to build navigation.\n\n\n**`dist/manifest.json` (Excerpt):**",
      "code_blocks": [
        "enabled: true\ntitle: My Go Library\ndescription: A brief description of what this library does.\ncategory: Libraries\nsettings:\n  model: gemini-1.5-flash-latest\n  output_dir: docs\nsections:\n  - name: introduction\n    title: Introduction\n    order: 10\n    prompt: prompts/introduction.md\n    output: introduction.md\n  - name: usage\n    title: Usage\n    order: 20\n    prompt: prompts/usage.md\n    output: usage.md",
        "Based on the provided project context, write a concise introduction to this project. Explain its primary purpose and the problem it solves.",
        "Based on the provided project context, generate a basic usage guide. Include a simple code example demonstrating how to use the core functionality.",
        ".\n├── docs/\n│   ├── docgen.config.yml\n│   ├── introduction.md      # Generated documentation\n│   ├── usage.md             # Generated documentation\n│   └── prompts/\n│       ├── introduction.md\n│       └── usage.md\n└── go.mod",
        "enabled: true\ntitle: Advanced CLI Tool\ndescription: A CLI tool with advanced features and a well-defined configuration schema.\ncategory: Tools\nsettings:\n  model: gemini-1.5-pro-latest\n  rules_file: docs.rules\n  structured_output_file: docs/generated.json\n  output_dir: docs/generated\nreadme:\n  template: docs/README.md.tpl\n  output: README.md\n  source_section: introduction\n  strip_lines: 1 # Strips the H1 title from the source file\nsections:\n  - name: introduction\n    title: Introduction\n    order: 10\n    prompt: prompts/introduction.md\n    output: introduction.md\n    json_key: overview\n  - name: installation\n    title: Installation\n    order: 20\n    prompt: prompts/installation.md\n    output: installation.md\n  - name: configuration\n    title: Configuration Reference\n    order: 30\n    type: schema_to_md\n    source: schema/config.schema.json\n    output: configuration.md\n    model: gemini-1.5-flash-latest # Use a faster model for this structured task",
        ".\n├── README.md                # Generated from template\n├── docs/\n│   ├── docgen.config.yml\n│   ├── docs.rules\n│   ├── README.md.tpl\n│   ├── generated.json         # Structured JSON output\n│   └── generated/\n│       ├── introduction.md\n│       ├── installation.md\n│       └── configuration.md   # Generated from schema\n└── schema/\n    └── config.schema.json",
        ".\n├── grove.yml\n├── Makefile\n├── dist/                  # Aggregated output appears here\n└── packages/\n    ├── tool-a/\n    │   ├── docs/\n    │   │   └── docgen.config.yml\n    │   └── ...\n    └── lib-b/\n        ├── docs/\n        │   └── docgen.config.yml\n        └── ...",
        "make docs",
        "./dist/\n├── manifest.json\n├── tool-a/\n│   ├── introduction.md\n│   └── usage.md\n└── lib-b/\n    ├── introduction.md\n    └── api-reference.md",
        "{\n  \"packages\": [\n    {\n      \"name\": \"tool-a\",\n      \"title\": \"Tool A\",\n      \"description\": \"The first tool in the ecosystem.\",\n      \"category\": \"Tools\",\n      \"docs_path\": \"./tool-a\",\n      \"version\": \"v1.2.0\",\n      \"sections\": [\n        { \"title\": \"Introduction\", \"path\": \"./tool-a/introduction.md\" },\n        { \"title\": \"Usage\", \"path\": \"./tool-a/usage.md\" }\n      ]\n    },\n    {\n      \"name\": \"lib-b\",\n      \"title\": \"Library B\",\n      // ...\n    }\n  ],\n  \"generated_at\": \"...\"\n}"
      ]
    },
    "overview": {
      "title": "Overview",
      "content": "`grove-docgen` is a command-line tool for generating documentation for software projects using Large Language Models (LLMs). It integrates with the Grove ecosystem to create documentation from source code and project structure.\n\n\u003c!-- placeholder for animated gif --\u003e",
      "subsections": [
        {
          "title": "Key Features",
          "content": "*   **Section-Based Architecture**: Documentation is defined in a `docgen.config.yml` file, organized into logical sections. Each section is configured with its own prompt, output file, and can override global settings like the LLM model.\n*   **Customizable Prompts**: The `docgen init` command creates a `docs/prompts/` directory containing starter prompt files. These markdown files can be modified to direct the LLM's content generation.\n*   **Interactive Customization**: The `docgen customize` command creates a `grove-flow` plan, using AI agents or structured prompts to interactively customize and generate documentation.\n*   **Multi-Model Support**: The tool leverages `grove llm`, which allows the use of different LLM providers and models (e.g., Gemini, Claude, OpenAI) for different documentation sections.\n*   **Workspace-Aware Context**: It uses `grove cx` to analyze project files based on configurable rules. This context is provided to the LLM during generation.\n*   **README Synchronization**: A `sync-readme` command updates the project's root `README.md` by injecting content from a specified documentation section into a template file.\n*   **Documentation Aggregation**: The `aggregate` command discovers all enabled packages in a workspace, copies their documentation into an output directory, and creates a `manifest.json` file.\n*   **Schema Tools**: Includes commands to generate JSON schemas from Go types (`schema generate`) and enrich them with LLM-generated descriptions (`schema enrich`)."
        },
        {
          "title": "Ecosystem Integration",
          "content": "`grove-docgen` functions as a component within the Grove developer tool ecosystem.\n\n*   It uses `grove cx` to build context from source code.\n*   It uses `grove llm` to send requests to language models.\n*   It uses `grove-flow` to create interactive documentation plans.\n*   It recognizes the workspace structure defined in the ecosystem's `grove.yml` file.\n*   Prompts can be stored and resolved from a central `grove-notebook` location, with a `migrate-prompts` command to assist in moving them.\n\nThis design allows `docgen` to operate with an understanding of the project and its related components."
        },
        {
          "title": "How It Works",
          "content": "The documentation generation process consists of the following steps:\n\n1.  **Configuration Load**: `docgen` reads the `docs/docgen.config.yml` file to determine which sections to generate.\n2.  **Context Generation**: It executes `grove cx generate`, which reads project files according to patterns in a rules file and prepares context for the LLM.\n3.  **Prompt Resolution**: It locates and reads the specified prompt file for the section, checking first in the associated `grove-notebook` and then falling back to the local `docs/prompts/` directory.\n4.  **LLM Invocation**: It calls `grove llm request`, sending the generated context and the prompt content to the configured language model.\n5.  **Output Writing**: The markdown response from the LLM is written to the section's specified output file.\n6.  **JSON Regeneration (Optional)**: If configured, it parses the generated markdown files to create a structured JSON representation of the documentation.\n\n### Installation\n\nInstall via the Grove meta-CLI:\n\nVerify installation:\n\nRequires the `grove` meta-CLI. See the [Grove Installation Guide](https://github.com/mattsolo1/grove-meta/blob/main/docs/02-installation.md) if you don't have it installed.",
          "code_blocks": [
            "grove install docgen",
            "docgen version"
          ]
        }
      ]
    }
  }
}