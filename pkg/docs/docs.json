{
  "sections": {
    "command-reference": {
      "title": "Command Reference",
      "content": "This document provides a comprehensive reference for all `docgen` commands, organized by function.",
      "subsections": [
        {
          "title": "Core Commands",
          "content": "These commands form the primary workflow for initializing, generating, and managing documentation.\n\n### docgen init\n\nInitializes a new documentation generation configuration for the current project.\n\n-   **Usage**: `docgen init [flags]`\n-   **Description**: Creates a `docs/` directory with a default `docgen.config.yml` file and a set of starter prompt files in `docs/prompts/`. This command sets up the necessary structure to begin generating documentation. It will not overwrite existing files.\n-   **Flags**:\n\n| Flag | Description | Default |\n| :--- | :--- | :--- |\n| `--type` | The type of project to initialize. Currently, only `library` is supported. | `library` |\n| `--model` | The default LLM model to use for generation (e.g., `gemini-1.5-flash-latest`). | (none) |\n| `--regeneration-mode` | The regeneration mode: `scratch` or `reference`. | (none) |\n| `--rules-file` | The name of the rules file for context generation (e.g., `docs.rules`). | (none) |\n| `--structured-output-file` | The path for the structured JSON output file. | (none) |\n| `--system-prompt` | The system prompt to use: `default` or a path to a custom file. | (none) |\n| `--output-dir` | The output directory for generated documentation. | (none) |\n\n-   **Examples**:\n    ```bash\n    # Initialize with default settings\n    docgen init\n\n    # Initialize and specify a default model and rules file\n    docgen init --model gemini-2.5-pro --rules-file docs.rules\n    ```\n\n---\n\n### docgen generate\n\nGenerates documentation for the current package based on its configuration.\n\n-   **Usage**: `docgen generate [flags]`\n-   **Description**: Reads the `docs/docgen.config.yml` file, builds the necessary context using `grove-context`, calls an LLM for each configured section, and writes the generated Markdown files to the specified output directory.\n-   **Flags**:\n\n| Flag | Shorthand | Description |\n| :--- | :--- | :--- |\n| `--section` | `-s` | Generate only the specified sections by name. Can be used multiple times. |\n\n-   **Examples**:\n    ```bash\n    # Generate all documentation sections defined in the config\n    docgen generate\n\n    # Generate only the 'overview' section\n    docgen generate --section overview\n\n    # Generate the 'overview' and 'examples' sections\n    docgen generate -s overview -s examples\n    ```\n\n---\n\n### docgen aggregate\n\nDiscovers all `docgen`-enabled packages in a workspace and aggregates their documentation into a single output directory.\n\n-   **Usage**: `docgen aggregate [flags]`\n-   **Description**: This command is designed for monorepos. It scans the workspace for packages with an enabled `docgen.config.yml`, copies their final documentation into a unified directory, and creates a `manifest.json` file that describes all the collected documentation, which is useful for static site generators.\n-   **Flags**:\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--output-dir` | `-o` | The directory to save the aggregated documentation. | `dist` |\n\n-   **Examples**:\n    ```bash\n    # Aggregate documentation from all workspace packages into the ./dist directory\n    docgen aggregate\n\n    # Specify a different output directory\n    docgen aggregate --output-dir ./public/docs\n    ```\n\n---\n\n### docgen sync-readme\n\nGenerates the `README.md` from a template and a source documentation file.\n\n-   **Usage**: `docgen sync-readme [flags]`\n-   **Description**: Synchronizes the project's `README.md` based on the `readme` configuration in `docs/docgen.config.yml`. It reads a template file, injects a specified documentation section into it, and writes the result to the output `README.md` file.\n-   **Flags**:\n\n| Flag | Description |\n| :--- | :--- |\n| `--generate-source` | Generate the source documentation section before syncing the README. |\n\n-   **Examples**:\n    ```bash\n    # Sync the README using the existing documentation\n    docgen sync-readme\n\n    # Regenerate the overview section first, then sync the README\n    docgen sync-readme --generate-source\n    ```\n\n---"
        },
        {
          "title": "Advanced Commands",
          "content": "These commands provide more specialized functionality for customization and maintenance.\n\n### docgen customize\n\nCreates a `grove-flow` plan for interactively customizing and generating documentation.\n\n-   **Usage**: `docgen customize [flags]`\n-   **Description**: This command bridges `docgen` with `grove-flow` to create a guided, interactive workflow for documentation generation. It reads your `docgen.config.yml`, creates a new `grove-flow` plan, and passes your configuration to the plan as variables. This allows you to use AI agents or structured prompts to refine your documentation before final generation.\n-   **Prerequisites**: The `flow` command must be installed and available in your `PATH`.\n-   **Flags**:\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--recipe-type` | `-r` | The recipe to use: `agent` for an interactive AI agent, or `prompts` for a structured prompt-based flow. | `agent` |\n\n-   **Examples**:\n    ```bash\n    # Create a customization plan using the default 'agent' recipe\n    docgen customize\n\n    # Create a plan using the 'prompts' recipe\n    docgen customize --recipe-type prompts\n\n    # After creating the plan, run it with grove-flow\n    flow plan run\n    ```\n\n---\n\n### docgen regen-json\n\nRegenerates the structured JSON output from existing Markdown files.\n\n-   **Usage**: `docgen regen-json`\n-   **Description**: If you have configured a `structured_output_file` in your `docgen.config.yml`, this command will re-parse your existing generated Markdown files and update the JSON output. It does not call any LLMs or modify the Markdown files, making it a fast way to update the structured data if you've made manual edits or if the parsing logic has changed.\n-   **Arguments**: None\n-   **Flags**: None\n-   **Examples**:\n    ```bash\n    # Regenerate the JSON output based on the current state of the markdown files\n    docgen regen-json\n    ```\n\n---\n\n### docgen recipe\n\nManages and displays documentation recipes for use with `grove-flow`.\n\n-   **Usage**: `docgen recipe [subcommand]`\n-   **Description**: This is a parent command for working with `docgen` recipes.\n-   **Subcommands**:\n    -   **`print`**: Prints all available `docgen` recipes in a JSON format that is consumable by `grove-flow`. This is used internally by the `docgen customize` command.\n        -   **Usage**: `docgen recipe print`\n        -   **Example**:\n            ```bash\n            # Print available recipes to stdout\n            docgen recipe print\n            ```\n\n---"
        },
        {
          "title": "Utility Commands",
          "content": "### docgen version\n\nPrints the version information for the `docgen` binary.\n\n-   **Usage**: `docgen version [flags]`\n-   **Description**: Displays the version, commit hash, and build date of the installed `docgen` command.\n-   **Flags**:\n\n| Flag | Description |\n| :--- | :--- |\n| `--json` | Output the version information in JSON format. |\n\n-   **Examples**:\n    ```bash\n    # Display version information in a human-readable format\n    docgen version\n\n    # Get version information as JSON for scripting\n    docgen version --json\n    ```"
        }
      ]
    },
    "configuration": {
      "title": "Configuration",
      "content": "",
      "subsections": [
        {
          "title": "Docgen Settings",
          "content": "This section configures the core metadata, generation settings, and structure of the documentation for the project.\n\n| Property | Description |\n| :--- | :--- |\n| `enabled` | (boolean, required, default: true) \u003cbr\u003e A master switch to enable or disable documentation generation for this specific package. If set to `false`, the `docgen` tool will skip this package during bulk operations like `aggregate` or `watch`. |\n| `title` | (string, required) \u003cbr\u003e The display title for the package's documentation. This is used in the sidebar, site navigation, and aggregated documentation views. |\n| `description` | (string, required) \u003cbr\u003e A brief summary of what the package does. This description may be used in index pages, cards, or SEO metadata for the generated website. |\n| `category` | (string, required) \u003cbr\u003e Defines the organizational category for the documentation (e.g., 'Core Libraries', 'Tools', 'Templates'). This helps group related packages together in the generated website sidebar. |\n| `settings` | (object, optional) \u003cbr\u003e Contains global configuration settings for the documentation generation process, such as the default LLM model to use, output directories, and context rules. |\n| `sections` | (array, required) \u003cbr\u003e A list of individual documentation sections to be generated. Each item in this array corresponds to a specific topic or file (e.g., \"Overview\", \"Usage\", \"API Reference\"). |\n| `readme` | (object, optional) \u003cbr\u003e Configuration for automatically synchronizing the project's root `README.md` file using generated documentation content. |\n| `sidebar` | (object, optional) \u003cbr\u003e Configuration for the website sidebar display, including category ordering and icons. |\n| `logos` | (array, optional) \u003cbr\u003e A list of additional logo files (absolute paths or paths starting with `~/`) to copy to the output directory during aggregation. This is useful for including assets that aren't generated but are referenced by the documentation. |\n\n\n### Settings Configuration\n\nGlobal settings that control the generation process and environment.\n\n| Property | Description |\n| :--- | :--- |\n| `model` | (string, optional) \u003cbr\u003e The default LLM model to use for generation across all sections (e.g., `gemini-2.0-flash`, `claude-3-opus`). Can be overridden per section. |\n| `output_mode` | (string, optional) \u003cbr\u003e Determines how the output is structured. `package` (default) treats the directory as a standard package. `sections` treats it as a collection of website content sections (e.g., overview, concepts), where subdirectories represent distinct content collections. |\n| `ecosystems` | (array, optional) \u003cbr\u003e A list of ecosystem names to include when aggregating documentation. If not specified, defaults to the current ecosystem. |\n| `regeneration_mode` | (string, optional) \u003cbr\u003e Controls how documentation is updated. `scratch` generates fresh content. `reference` (default) provides the existing file as context to the LLM to preserve manual edits. |\n| `rules_file` | (string, optional) \u003cbr\u003e Path to a custom rules file (e.g., `.cx/rules`) used by `cx generate` to build the context for the LLM. |\n| `structured_output_file` | (string, optional) \u003cbr\u003e If defined, parses the generated Markdown into a structured JSON file at this path. |\n| `system_prompt` | (string, optional) \u003cbr\u003e Path to a custom system prompt file or `default` to use the built-in technical writer persona. |\n| `output_dir` | (string, optional) \u003cbr\u003e The directory where generated documentation files will be saved. Defaults to `docs`. |\n| `temperature` | (number, optional) \u003cbr\u003e Global control for randomness in generation (0.0-1.0). Higher values produce more creative output, while lower values are more deterministic. |\n| `top_p` | (number, optional) \u003cbr\u003e Global nucleus sampling parameter (0.0-1.0). Controls the diversity of the generated text. |\n| `top_k` | (integer, optional) \u003cbr\u003e Global top-k sampling parameter. Limits the vocabulary used during generation. |\n| `max_output_tokens` | (integer, optional) \u003cbr\u003e Global limit on the length of generated content. |\n\n\n### Sections Configuration\n\nEach item in the `sections` array defines a specific piece of documentation to be generated or captured.\n\n| Property | Description |\n| :--- | :--- |\n| `name` | (string, required) \u003cbr\u003e A unique identifier for this section. Used for referencing in `readme.source_section`. |\n| `title` | (string, required) \u003cbr\u003e The human-readable display title. Often used as the top-level heading (# Title) in the output. |\n| `output` | (string, required) \u003cbr\u003e The filename for the generated Markdown output (e.g., `01-overview.md`). |\n| `order` | (integer, required) \u003cbr\u003e A numeric value for sorting sections in the aggregated documentation. |\n| `prompt` | (string, optional) \u003cbr\u003e Path to the prompt file relative to `docs/` (e.g., `prompts/01-overview.md`). Required for standard generation. |\n| `model` | (string, optional) \u003cbr\u003e Override the global model setting for this section. If not specified, uses the global model setting. |\n| `status` | (string, optional) \u003cbr\u003e Publication status: `draft` (notebook only), `dev` (dev website), or `production`. Default is usually `draft`. |\n| `type` | (string, optional) \u003cbr\u003e The type of generation: `schema_to_md` (JSON schema to Markdown), `doc_sections` (aggregation of other docs), `capture` (CLI help output), or standard generation (default). |\n| `output_dir` | (string, optional) \u003cbr\u003e Override output directory for this specific section. Useful in `sections` output mode to direct files to specific content collections. |\n| `agg_strip_lines` | (integer, optional) \u003cbr\u003e Number of lines to strip from the top of this section's content during aggregation. Useful for removing headers that might not be appropriate in aggregated context. |\n| `json_key` | (string, optional) \u003cbr\u003e Optional key to use when parsing this section into the structured JSON output file. |\n| `schemas` | (array, optional) \u003cbr\u003e For `schema_to_md` type: A list of objects containing `path` (to schema file) and `title` to aggregate multiple schemas into one document. |\n| `doc_sources` | (array, optional) \u003cbr\u003e For `doc_sections` type: A list of source configurations (`package`, `doc`, `title`, `description`) to pull content from other generated docs. |\n| `binary` | (string, optional) \u003cbr\u003e For `capture` type: The name of the binary to execute (e.g., `grove`). |\n| `format` | (string, optional) \u003cbr\u003e For `capture` type: Output format, either `styled` (HTML terminal block) or `plain` (Markdown code block). |\n| `depth` | (integer, optional, default: 5) \u003cbr\u003e For `capture` type: Maximum recursion depth for subcommand crawling. |\n| `subcommand_order` | (array, optional) \u003cbr\u003e For `capture` type: Priority order for sorting subcommands. |\n| `temperature` | (number, optional) \u003cbr\u003e Temperature override for this section. |\n| `top_p` | (number, optional) \u003cbr\u003e Top-p override for this section. |\n| `top_k` | (integer, optional) \u003cbr\u003e Top-k override for this section. |\n| `max_output_tokens` | (integer, optional) \u003cbr\u003e Maximum output tokens override for this section. |\n| `source` | (string, optional) \u003cbr\u003e **Deprecated**: Use `schemas` list instead. Source file for `schema_to_md` type. |\n\n\n### Readme Synchronization\n\nThe `readme` object configures how the root `README.md` is generated from a template and a specific documentation section.\n\n| Property | Description |\n| :--- | :--- |\n| `template` | (string, required, default: docs/README.md.tpl) \u003cbr\u003e Path to the README template file (relative to package root). |\n| `output` | (string, required, default: README.md) \u003cbr\u003e Path to the output README file (relative to package root). |\n| `source_section` | (string, required, default: introduction) \u003cbr\u003e The `name` of the documentation section to inject into the template. |\n| `strip_lines` | (integer, optional, default: 0) \u003cbr\u003e Number of lines to strip from the top of the source documentation file before injection. Useful for removing headings, blank lines, or metadata. |\n| `generate_toc` | (boolean, optional, default: false) \u003cbr\u003e Whether to automatically generate a table of contents from documentation sections. Requires `\u003c!-- DOCGEN:TOC:START --\u003e` and `\u003c!-- DOCGEN:TOC:END --\u003e` markers in the template. |\n| `base_url` | (string, optional) \u003cbr\u003e Base URL for converting root-relative paths in the documentation to absolute URLs in the README. |\n| `logo` | (object, optional) \u003cbr\u003e Configuration for generating a combined logo+text header image. |\n\n\n#### Logo Configuration\n\n| Property | Description |\n| :--- | :--- |\n| `input` | (string, required) \u003cbr\u003e Path to input logo SVG (relative to base_url root or absolute). |\n| `output` | (string, required) \u003cbr\u003e Path for output logo-with-text SVG. |\n| `text` | (string, required) \u003cbr\u003e Text to display below logo. |\n| `font` | (string, required) \u003cbr\u003e Path to TTF/OTF font file. |\n| `color` | (string, optional) \u003cbr\u003e Text color (hex). |\n| `spacing` | (number, optional, default: 35) \u003cbr\u003e Spacing between logo and text. |\n| `text_scale` | (number, optional, default: 1.1) \u003cbr\u003e Text width as proportion of logo. |\n| `width` | (number, optional, default: 200) \u003cbr\u003e Output SVG width in pixels. |\n\n### Sidebar Configuration\n\nConfiguration for the website sidebar display.\n\n| Property | Description |\n| :--- | :--- |\n| `category_order` | (array, optional) \u003cbr\u003e Defines the display order of categories in the sidebar. |\n| `categories` | (object, optional) \u003cbr\u003e Map of category names to configuration (icon, flat mode, package order). |\n| `packages` | (object, optional) \u003cbr\u003e Map of package names to configuration (icon, color, status). |\n| `package_category_override` | (object, optional) \u003cbr\u003e Overrides the default category for specific packages. |",
          "code_blocks": [
            "title = \"Grove Core\"\ndescription = \"Core libraries for the Grove ecosystem\"\ncategory = \"Libraries\"\nenabled = true\nlogos = [\"~/assets/grove-logo-dark.svg\"]\n\n[settings]\nmodel = \"claude-3-opus-20240229\"",
            "[settings]\nmodel = \"gemini-2.0-flash\"\noutput_dir = \"docs\"\nregeneration_mode = \"reference\"\ntemperature = 0.2",
            "[[sections]]\nname = \"overview\"\ntitle = \"Overview\"\noutput = \"01-overview.md\"\nprompt = \"prompts/01-overview.md\"\norder = 1\nstatus = \"production\"\n\n[[sections]]\nname = \"cli-reference\"\ntitle = \"CLI Reference\"\noutput = \"05-commands.md\"\ntype = \"capture\"\nbinary = \"grove\"\norder = 5",
            "[readme]\ntemplate = \"docs/README.md.tpl\"\noutput = \"README.md\"\nsource_section = \"overview\"\ngenerate_toc = true",
            "[sidebar]\ncategory_order = [\"Guides\", \"Libraries\", \"Tools\"]\n\n[sidebar.categories.Tools]\nicon = \"ph:terminal\"\nflat = true"
          ]
        }
      ]
    },
    "examples": {
      "title": "Examples",
      "content": "Here are three practical examples for using `grove-docgen`, demonstrating increasing complexity from a basic setup to advanced configuration and full ecosystem integration.\n\n### Example 1: Basic Setup\n\nThis example covers initializing `grove-docgen` in a new project and generating a simple set of documentation.\n\n#### Configuration (`docs/docgen.config.yml`)\n\nFirst, run `docgen init` to create the initial configuration and prompt files. The resulting `docgen.config.yml` will look similar to this:\n\n\n#### Sample Prompts\n\nThe `docgen init` command creates starter prompts.\n\n**`docs/prompts/introduction.md`:**\n\n**`docs/prompts/usage.md`:**\n\n#### Commands\n\n1.  **Initialize Configuration:**\n    ```sh\n    docgen init\n    ```\n2.  **Generate Documentation:**\n    ```sh\n    docgen generate\n    ```\n    This command reads `docs/docgen.config.yml`, builds project context by running `grove cx generate` internally, sends each prompt to the LLM, and saves the results.\n\n#### Expected Output Structure\n\nAfter running the commands, your project will have the following structure:\n\n\n### Example 2: Advanced Configuration\n\nThis example demonstrates a more complex setup, including README synchronization, structured JSON output, and documentation generated from a JSON schema.\n\n#### Configuration (`docs/docgen.config.yml`)\n\nThis configuration adds a `readme` section, a `structured_output_file`, custom context rules, and a section for generating documentation from a schema.\n\n\n#### Supporting Files\n\n*   **`docs/docs.rules` (Context Rules):**\n    ```\n    # Include all source code\n    **/*.go\n    # Exclude tests\n    !**/*_test.go\n    # Include the schema file\n    schema/config.schema.json\n    ```\n*   **`schema/config.schema.json` (Source Schema):**\n    ```json\n    {\n      \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n      \"title\": \"Tool Configuration\",\n      \"description\": \"Configuration for the Advanced CLI Tool.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"port\": {\n          \"type\": \"integer\",\n          \"description\": \"The network port to listen on.\"\n        },\n        \"log_level\": {\n          \"type\": \"string\",\n          \"enum\": [\"debug\", \"info\", \"warn\", \"error\"]\n        }\n      }\n    }\n    ```\n*   **`docs/README.md.tpl` (README Template):**\n    ```markdown\n    # {{ .Title }}\n\n    {{ .Description }}\n\n    \u003c!-- DOCGEN:INTRODUCTION:START --\u003e\n    \u003c!-- Content will be injected here --\u003e\n    \u003c!-- DOCGEN:INTRODUCTION:END --\u003e\n\n    ## More Information\n\n    See the full documentation in the `docs/generated` directory.\n    ```\n\n#### Commands\n\n1.  **Generate all documentation sections:**\n    ```sh\n    docgen generate\n    ```\n2.  **Synchronize the README:**\n    ```sh\n    docgen sync-readme\n    ```\n3.  **(Optional) Regenerate JSON from Markdown:** If you manually edit the Markdown files, you can update the JSON without calling the LLM again.\n    ```sh\n    docgen regen-json\n    ```\n\n#### Expected Output Structure\n\nThe process generates documentation, a structured JSON file, and updates the root `README.md`.\n\n\n### Example 3: Grove Ecosystem Integration\n\nThis example shows how `grove-docgen` operates in a monorepo (or \"ecosystem\") with multiple packages, aggregating all documentation into a central directory for a website.\n\n#### Project Structure\n\n\n#### Configuration\n\n*   **`grove.yml` (Ecosystem Root):**\n    ```yaml\n    workspaces:\n      - \"packages/*\"\n    ```\n*   **`packages/tool-a/docs/docgen.config.yml`:**\n    ```yaml\n    enabled: true\n    title: Tool A\n    description: The first tool in the ecosystem.\n    category: Tools\n    # ... sections ...\n    ```\n*   **`packages/lib-b/docs/docgen.config.yml`:**\n    ```yaml\n    enabled: true\n    title: Library B\n    description: A shared library used by other tools.\n    category: Libraries\n    # ... sections ...\n    ```\n*   **`Makefile` (Ecosystem Root):**\n    ```makefile\n    .PHONY: docs\n\n    docs: generate-docs aggregate-docs\n\n    generate-docs:\n    \t@echo \"Generating documentation for all packages...\"\n    \tgrove ws foreach --no-private -- exec docgen generate\n\n    aggregate-docs:\n    \t@echo \"Aggregating all documentation...\"\n    \tdocgen aggregate -o dist\n    ```\n\n#### Commands\n\nFrom the ecosystem root, a single command can generate and aggregate all documentation.\n\n\nThis workflow performs two main actions:\n1.  `grove ws foreach ... exec docgen generate`: Runs `docgen generate` inside each package defined in `grove.yml`. This leverages `grove-context` to build context relevant to each specific package.\n2.  `docgen aggregate -o dist`: Scans all workspace packages, finds the generated documentation for those with `enabled: true`, copies the artifacts into the `dist` directory, and creates a `manifest.json`.\n\n#### Expected Output Structure\n\nThe `dist` directory contains all documentation, organized by package, with a manifest file that a static site generator can use to build navigation.\n\n\n**`dist/manifest.json` (Excerpt):**",
      "code_blocks": [
        "enabled: true\ntitle: My Go Library\ndescription: A brief description of what this library does.\ncategory: Libraries\nsettings:\n  model: gemini-1.5-flash-latest\n  output_dir: docs\nsections:\n  - name: introduction\n    title: Introduction\n    order: 10\n    prompt: prompts/introduction.md\n    output: introduction.md\n  - name: usage\n    title: Usage\n    order: 20\n    prompt: prompts/usage.md\n    output: usage.md",
        "Based on the provided project context, write a concise introduction to this project. Explain its primary purpose and the problem it solves.",
        "Based on the provided project context, generate a basic usage guide. Include a simple code example demonstrating how to use the core functionality.",
        ".\n├── docs/\n│   ├── docgen.config.yml\n│   ├── introduction.md      # Generated documentation\n│   ├── usage.md             # Generated documentation\n│   └── prompts/\n│       ├── introduction.md\n│       └── usage.md\n└── go.mod",
        "enabled: true\ntitle: Advanced CLI Tool\ndescription: A CLI tool with advanced features and a well-defined configuration schema.\ncategory: Tools\nsettings:\n  model: gemini-1.5-pro-latest\n  rules_file: docs.rules\n  structured_output_file: docs/generated.json\n  output_dir: docs/generated\nreadme:\n  template: docs/README.md.tpl\n  output: README.md\n  source_section: introduction\n  strip_lines: 1 # Strips the H1 title from the source file\nsections:\n  - name: introduction\n    title: Introduction\n    order: 10\n    prompt: prompts/introduction.md\n    output: introduction.md\n    json_key: overview\n  - name: installation\n    title: Installation\n    order: 20\n    prompt: prompts/installation.md\n    output: installation.md\n  - name: configuration\n    title: Configuration Reference\n    order: 30\n    type: schema_to_md\n    source: schema/config.schema.json\n    output: configuration.md\n    model: gemini-1.5-flash-latest # Use a faster model for this structured task",
        ".\n├── README.md                # Generated from template\n├── docs/\n│   ├── docgen.config.yml\n│   ├── docs.rules\n│   ├── README.md.tpl\n│   ├── generated.json         # Structured JSON output\n│   └── generated/\n│       ├── introduction.md\n│       ├── installation.md\n│       └── configuration.md   # Generated from schema\n└── schema/\n    └── config.schema.json",
        ".\n├── grove.yml\n├── Makefile\n├── dist/                  # Aggregated output appears here\n└── packages/\n    ├── tool-a/\n    │   ├── docs/\n    │   │   └── docgen.config.yml\n    │   └── ...\n    └── lib-b/\n        ├── docs/\n        │   └── docgen.config.yml\n        └── ...",
        "make docs",
        "./dist/\n├── manifest.json\n├── tool-a/\n│   ├── introduction.md\n│   └── usage.md\n└── lib-b/\n    ├── introduction.md\n    └── api-reference.md",
        "{\n  \"packages\": [\n    {\n      \"name\": \"tool-a\",\n      \"title\": \"Tool A\",\n      \"description\": \"The first tool in the ecosystem.\",\n      \"category\": \"Tools\",\n      \"docs_path\": \"./tool-a\",\n      \"version\": \"v1.2.0\",\n      \"sections\": [\n        { \"title\": \"Introduction\", \"path\": \"./tool-a/introduction.md\" },\n        { \"title\": \"Usage\", \"path\": \"./tool-a/usage.md\" }\n      ]\n    },\n    {\n      \"name\": \"lib-b\",\n      \"title\": \"Library B\",\n      // ...\n    }\n  ],\n  \"generated_at\": \"...\"\n}"
      ]
    },
    "overview": {
      "title": "Overview",
      "content": "`docgen` is a command-line tool for generating, managing, and aggregating documentation using Large Language Models (LLMs). It feeds repository context along with prompts to create accurate technical documentation, from single README sections to entire documentation websites.",
      "subsections": [
        {
          "title": "Core Mechanisms",
          "content": "**Section-Based Configuration**: Documentation is defined in `docgen.config.yml`. The configuration organizes documentation into logical \"sections\" (e.g., Overview, Usage). Each section maps a specific prompt file to an output Markdown file and can define specific LLM parameters or context rules.\n\n**Notebook Decoupling**: Configuration and prompts can reside either in the source repository or within a `nb` workspace. This allows documentation logic and drafting to occur independently of the source code, keeping repositories clean and enabling private iteration before publishing.\n\n**Context-Aware Generation**: The tool utilizes `grove cx` to assemble file-based context from the repository. It combines prompts, the previous documentation iteration, and `cx` codebase context to generate content via `grove llm`.\n\n**Aggregation \u0026 Manifests**: The `aggregate` command scans a workspace for enabled packages, collects their documentation based on status (`draft`, `dev`, `production`), and generates a `manifest.json`. This output drives static site generators (like Astro) for building unified documentation portals."
        },
        {
          "title": "Features",
          "content": "### Generation \u0026 Maintenance\n*   **`docgen generate`**: Generates documentation sections based on the configuration. Supports filtering by specific sections.\n*   **`docgen watch`**: Monitors documentation sources and triggers incremental rebuilds on file changes. Designed for integration with hot-reloading development servers.\n*   **`docgen sync-readme`**: Injects a specific generated documentation section into a `README.md.tpl` file. This ensures the repository README remains in sync with formal documentation.\n\n### Schema Tools\n*   **`docgen schema enrich`**: Parses JSON schemas and uses an LLM to generate descriptions for properties lacking them.\n*   **`docgen schema generate`**: A wrapper that executes `go generate ./...` to trigger code-based schema generation.\n\n### Workflow Management\n*   **`docgen sync`**: Transfers documentation between the `grove-notebook` (drafting environment) and the local repository (version control). Supports `to-repo` and `from-repo` directions.\n*   **`docgen customize`**: Generates a `grove-flow` plan to interactively customize documentation structure using AI agents.\n*   **`docgen logo generate`**: Creates combined SVG assets containing a logo and text, converting text to paths to ensure consistent rendering without external font dependencies."
        },
        {
          "title": "Integrations",
          "content": "*   **`cx`**: Used to generate repository context files based on `.grove/rules`.\n*   **`flow`**: Orchestrates interactive customization plans.\n*   **`nb`**: Resolves workspace locations for storing prompts and drafts outside the source repository."
        }
      ]
    }
  }
}