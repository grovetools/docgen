{
  "sections": {
    "command-reference": {
      "title": "Command Reference",
      "content": "This document provides a comprehensive reference for all `docgen` commands, organized by function.",
      "subsections": [
        {
          "title": "Core Commands",
          "content": "These commands form the primary workflow for initializing, generating, and managing documentation.\n\n### docgen init\n\nInitializes a new documentation generation configuration for the current project.\n\n-   **Usage**: `docgen init [flags]`\n-   **Description**: Creates a `docs/` directory with a default `docgen.config.yml` file and a set of starter prompt files in `docs/prompts/`. This command sets up the necessary structure to begin generating documentation. It will not overwrite existing files.\n-   **Flags**:\n\n| Flag | Description | Default |\n| :--- | :--- | :--- |\n| `--type` | The type of project to initialize. Currently, only `library` is supported. | `library` |\n| `--model` | The default LLM model to use for generation (e.g., `gemini-1.5-flash-latest`). | (none) |\n| `--regeneration-mode` | The regeneration mode: `scratch` or `reference`. | (none) |\n| `--rules-file` | The name of the rules file for context generation (e.g., `docs.rules`). | (none) |\n| `--structured-output-file` | The path for the structured JSON output file. | (none) |\n| `--system-prompt` | The system prompt to use: `default` or a path to a custom file. | (none) |\n| `--output-dir` | The output directory for generated documentation. | (none) |\n\n-   **Examples**:\n    ```bash\n    # Initialize with default settings\n    docgen init\n\n    # Initialize and specify a default model and rules file\n    docgen init --model gemini-2.5-pro --rules-file docs.rules\n    ```\n\n---\n\n### docgen generate\n\nGenerates documentation for the current package based on its configuration.\n\n-   **Usage**: `docgen generate [flags]`\n-   **Description**: Reads the `docs/docgen.config.yml` file, builds the necessary context using `grove-context`, calls an LLM for each configured section, and writes the generated Markdown files to the specified output directory.\n-   **Flags**:\n\n| Flag | Shorthand | Description |\n| :--- | :--- | :--- |\n| `--section` | `-s` | Generate only the specified sections by name. Can be used multiple times. |\n\n-   **Examples**:\n    ```bash\n    # Generate all documentation sections defined in the config\n    docgen generate\n\n    # Generate only the 'overview' section\n    docgen generate --section overview\n\n    # Generate the 'overview' and 'examples' sections\n    docgen generate -s overview -s examples\n    ```\n\n---\n\n### docgen aggregate\n\nDiscovers all `docgen`-enabled packages in a workspace and aggregates their documentation into a single output directory.\n\n-   **Usage**: `docgen aggregate [flags]`\n-   **Description**: This command is designed for monorepos. It scans the workspace for packages with an enabled `docgen.config.yml`, copies their final documentation into a unified directory, and creates a `manifest.json` file that describes all the collected documentation, which is useful for static site generators.\n-   **Flags**:\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--output-dir` | `-o` | The directory to save the aggregated documentation. | `dist` |\n\n-   **Examples**:\n    ```bash\n    # Aggregate documentation from all workspace packages into the ./dist directory\n    docgen aggregate\n\n    # Specify a different output directory\n    docgen aggregate --output-dir ./public/docs\n    ```\n\n---\n\n### docgen sync-readme\n\nGenerates the `README.md` from a template and a source documentation file.\n\n-   **Usage**: `docgen sync-readme [flags]`\n-   **Description**: Synchronizes the project's `README.md` based on the `readme` configuration in `docs/docgen.config.yml`. It reads a template file, injects a specified documentation section into it, and writes the result to the output `README.md` file.\n-   **Flags**:\n\n| Flag | Description |\n| :--- | :--- |\n| `--generate-source` | Generate the source documentation section before syncing the README. |\n\n-   **Examples**:\n    ```bash\n    # Sync the README using the existing documentation\n    docgen sync-readme\n\n    # Regenerate the overview section first, then sync the README\n    docgen sync-readme --generate-source\n    ```\n\n---"
        },
        {
          "title": "Advanced Commands",
          "content": "These commands provide more specialized functionality for customization and maintenance.\n\n### docgen customize\n\nCreates a `grove-flow` plan for interactively customizing and generating documentation.\n\n-   **Usage**: `docgen customize [flags]`\n-   **Description**: This command bridges `docgen` with `grove-flow` to create a guided, interactive workflow for documentation generation. It reads your `docgen.config.yml`, creates a new `grove-flow` plan, and passes your configuration to the plan as variables. This allows you to use AI agents or structured prompts to refine your documentation before final generation.\n-   **Prerequisites**: The `flow` command must be installed and available in your `PATH`.\n-   **Flags**:\n\n| Flag | Shorthand | Description | Default |\n| :--- | :--- | :--- | :--- |\n| `--recipe-type` | `-r` | The recipe to use: `agent` for an interactive AI agent, or `prompts` for a structured prompt-based flow. | `agent` |\n\n-   **Examples**:\n    ```bash\n    # Create a customization plan using the default 'agent' recipe\n    docgen customize\n\n    # Create a plan using the 'prompts' recipe\n    docgen customize --recipe-type prompts\n\n    # After creating the plan, run it with grove-flow\n    flow plan run\n    ```\n\n---\n\n### docgen regen-json\n\nRegenerates the structured JSON output from existing Markdown files.\n\n-   **Usage**: `docgen regen-json`\n-   **Description**: If you have configured a `structured_output_file` in your `docgen.config.yml`, this command will re-parse your existing generated Markdown files and update the JSON output. It does not call any LLMs or modify the Markdown files, making it a fast way to update the structured data if you've made manual edits or if the parsing logic has changed.\n-   **Arguments**: None\n-   **Flags**: None\n-   **Examples**:\n    ```bash\n    # Regenerate the JSON output based on the current state of the markdown files\n    docgen regen-json\n    ```\n\n---\n\n### docgen recipe\n\nManages and displays documentation recipes for use with `grove-flow`.\n\n-   **Usage**: `docgen recipe [subcommand]`\n-   **Description**: This is a parent command for working with `docgen` recipes.\n-   **Subcommands**:\n    -   **`print`**: Prints all available `docgen` recipes in a JSON format that is consumable by `grove-flow`. This is used internally by the `docgen customize` command.\n        -   **Usage**: `docgen recipe print`\n        -   **Example**:\n            ```bash\n            # Print available recipes to stdout\n            docgen recipe print\n            ```\n\n---"
        },
        {
          "title": "Utility Commands",
          "content": "### docgen version\n\nPrints the version information for the `docgen` binary.\n\n-   **Usage**: `docgen version [flags]`\n-   **Description**: Displays the version, commit hash, and build date of the installed `docgen` command.\n-   **Flags**:\n\n| Flag | Description |\n| :--- | :--- |\n| `--json` | Output the version information in JSON format. |\n\n-   **Examples**:\n    ```bash\n    # Display version information in a human-readable format\n    docgen version\n\n    # Get version information as JSON for scripting\n    docgen version --json\n    ```"
        }
      ]
    },
    "examples": {
      "title": "Examples",
      "content": "Here are three practical examples for using `grove-docgen`, demonstrating increasing complexity from a basic setup to advanced configuration and full ecosystem integration.\n\n### Example 1: Basic Setup\n\nThis example covers initializing `grove-docgen` in a new project and generating a simple set of documentation.\n\n#### Configuration (`docs/docgen.config.yml`)\n\nFirst, run `docgen init` to create the initial configuration and prompt files. The resulting `docgen.config.yml` will look similar to this:\n\n\n#### Sample Prompts\n\nThe `docgen init` command creates starter prompts.\n\n**`docs/prompts/introduction.md`:**\n\n**`docs/prompts/usage.md`:**\n\n#### Commands\n\n1.  **Initialize Configuration:**\n    ```sh\n    docgen init\n    ```\n2.  **Generate Documentation:**\n    ```sh\n    docgen generate\n    ```\n    This command reads `docs/docgen.config.yml`, builds project context by running `grove cx generate` internally, sends each prompt to the LLM, and saves the results.\n\n#### Expected Output Structure\n\nAfter running the commands, your project will have the following structure:\n\n\n### Example 2: Advanced Configuration\n\nThis example demonstrates a more complex setup, including README synchronization, structured JSON output, and documentation generated from a JSON schema.\n\n#### Configuration (`docs/docgen.config.yml`)\n\nThis configuration adds a `readme` section, a `structured_output_file`, custom context rules, and a section for generating documentation from a schema.\n\n\n#### Supporting Files\n\n*   **`docs/docs.rules` (Context Rules):**\n    ```\n    # Include all source code\n    **/*.go\n    # Exclude tests\n    !**/*_test.go\n    # Include the schema file\n    schema/config.schema.json\n    ```\n*   **`schema/config.schema.json` (Source Schema):**\n    ```json\n    {\n      \"$schema\": \"http://json-schema.org/draft-07/schema#\",\n      \"title\": \"Tool Configuration\",\n      \"description\": \"Configuration for the Advanced CLI Tool.\",\n      \"type\": \"object\",\n      \"properties\": {\n        \"port\": {\n          \"type\": \"integer\",\n          \"description\": \"The network port to listen on.\"\n        },\n        \"log_level\": {\n          \"type\": \"string\",\n          \"enum\": [\"debug\", \"info\", \"warn\", \"error\"]\n        }\n      }\n    }\n    ```\n*   **`docs/README.md.tpl` (README Template):**\n    ```markdown\n    # {{ .Title }}\n\n    {{ .Description }}\n\n    \u003c!-- DOCGEN:INTRODUCTION:START --\u003e\n    \u003c!-- Content will be injected here --\u003e\n    \u003c!-- DOCGEN:INTRODUCTION:END --\u003e\n\n    ## More Information\n\n    See the full documentation in the `docs/generated` directory.\n    ```\n\n#### Commands\n\n1.  **Generate all documentation sections:**\n    ```sh\n    docgen generate\n    ```\n2.  **Synchronize the README:**\n    ```sh\n    docgen sync-readme\n    ```\n3.  **(Optional) Regenerate JSON from Markdown:** If you manually edit the Markdown files, you can update the JSON without calling the LLM again.\n    ```sh\n    docgen regen-json\n    ```\n\n#### Expected Output Structure\n\nThe process generates documentation, a structured JSON file, and updates the root `README.md`.\n\n\n### Example 3: Grove Ecosystem Integration\n\nThis example shows how `grove-docgen` operates in a monorepo (or \"ecosystem\") with multiple packages, aggregating all documentation into a central directory for a website.\n\n#### Project Structure\n\n\n#### Configuration\n\n*   **`grove.yml` (Ecosystem Root):**\n    ```yaml\n    workspaces:\n      - \"packages/*\"\n    ```\n*   **`packages/tool-a/docs/docgen.config.yml`:**\n    ```yaml\n    enabled: true\n    title: Tool A\n    description: The first tool in the ecosystem.\n    category: Tools\n    # ... sections ...\n    ```\n*   **`packages/lib-b/docs/docgen.config.yml`:**\n    ```yaml\n    enabled: true\n    title: Library B\n    description: A shared library used by other tools.\n    category: Libraries\n    # ... sections ...\n    ```\n*   **`Makefile` (Ecosystem Root):**\n    ```makefile\n    .PHONY: docs\n\n    docs: generate-docs aggregate-docs\n\n    generate-docs:\n    \t@echo \"Generating documentation for all packages...\"\n    \tgrove ws foreach --no-private -- exec docgen generate\n\n    aggregate-docs:\n    \t@echo \"Aggregating all documentation...\"\n    \tdocgen aggregate -o dist\n    ```\n\n#### Commands\n\nFrom the ecosystem root, a single command can generate and aggregate all documentation.\n\n\nThis workflow performs two main actions:\n1.  `grove ws foreach ... exec docgen generate`: Runs `docgen generate` inside each package defined in `grove.yml`. This leverages `grove-context` to build context relevant to each specific package.\n2.  `docgen aggregate -o dist`: Scans all workspace packages, finds the generated documentation for those with `enabled: true`, copies the artifacts into the `dist` directory, and creates a `manifest.json`.\n\n#### Expected Output Structure\n\nThe `dist` directory contains all documentation, organized by package, with a manifest file that a static site generator can use to build navigation.\n\n\n**`dist/manifest.json` (Excerpt):**",
      "code_blocks": [
        "enabled: true\ntitle: My Go Library\ndescription: A brief description of what this library does.\ncategory: Libraries\nsettings:\n  model: gemini-1.5-flash-latest\n  output_dir: docs\nsections:\n  - name: introduction\n    title: Introduction\n    order: 10\n    prompt: prompts/introduction.md\n    output: introduction.md\n  - name: usage\n    title: Usage\n    order: 20\n    prompt: prompts/usage.md\n    output: usage.md",
        "Based on the provided project context, write a concise introduction to this project. Explain its primary purpose and the problem it solves.",
        "Based on the provided project context, generate a basic usage guide. Include a simple code example demonstrating how to use the core functionality.",
        ".\n├── docs/\n│   ├── docgen.config.yml\n│   ├── introduction.md      # Generated documentation\n│   ├── usage.md             # Generated documentation\n│   └── prompts/\n│       ├── introduction.md\n│       └── usage.md\n└── go.mod",
        "enabled: true\ntitle: Advanced CLI Tool\ndescription: A CLI tool with advanced features and a well-defined configuration schema.\ncategory: Tools\nsettings:\n  model: gemini-1.5-pro-latest\n  rules_file: docs.rules\n  structured_output_file: docs/generated.json\n  output_dir: docs/generated\nreadme:\n  template: docs/README.md.tpl\n  output: README.md\n  source_section: introduction\n  strip_lines: 1 # Strips the H1 title from the source file\nsections:\n  - name: introduction\n    title: Introduction\n    order: 10\n    prompt: prompts/introduction.md\n    output: introduction.md\n    json_key: overview\n  - name: installation\n    title: Installation\n    order: 20\n    prompt: prompts/installation.md\n    output: installation.md\n  - name: configuration\n    title: Configuration Reference\n    order: 30\n    type: schema_to_md\n    source: schema/config.schema.json\n    output: configuration.md\n    model: gemini-1.5-flash-latest # Use a faster model for this structured task",
        ".\n├── README.md                # Generated from template\n├── docs/\n│   ├── docgen.config.yml\n│   ├── docs.rules\n│   ├── README.md.tpl\n│   ├── generated.json         # Structured JSON output\n│   └── generated/\n│       ├── introduction.md\n│       ├── installation.md\n│       └── configuration.md   # Generated from schema\n└── schema/\n    └── config.schema.json",
        ".\n├── grove.yml\n├── Makefile\n├── dist/                  # Aggregated output appears here\n└── packages/\n    ├── tool-a/\n    │   ├── docs/\n    │   │   └── docgen.config.yml\n    │   └── ...\n    └── lib-b/\n        ├── docs/\n        │   └── docgen.config.yml\n        └── ...",
        "make docs",
        "./dist/\n├── manifest.json\n├── tool-a/\n│   ├── introduction.md\n│   └── usage.md\n└── lib-b/\n    ├── introduction.md\n    └── api-reference.md",
        "{\n  \"packages\": [\n    {\n      \"name\": \"tool-a\",\n      \"title\": \"Tool A\",\n      \"description\": \"The first tool in the ecosystem.\",\n      \"category\": \"Tools\",\n      \"docs_path\": \"./tool-a\",\n      \"version\": \"v1.2.0\",\n      \"sections\": [\n        { \"title\": \"Introduction\", \"path\": \"./tool-a/introduction.md\" },\n        { \"title\": \"Usage\", \"path\": \"./tool-a/usage.md\" }\n      ]\n    },\n    {\n      \"name\": \"lib-b\",\n      \"title\": \"Library B\",\n      // ...\n    }\n  ],\n  \"generated_at\": \"...\"\n}"
      ]
    },
    "overview": {
      "title": "Overview",
      "content": "`docgen` is a command-line tool for generating, managing, and aggregating documentation using Large Language Models (LLMs). It feeds repository context along with prompts to create accurate technical documentation, from single README sections to entire documentation websites.",
      "subsections": [
        {
          "title": "Core Mechanisms",
          "content": "**Section-Based Configuration**: Documentation is defined in `docgen.config.yml`. The configuration organizes documentation into logical \"sections\" (e.g., Overview, Usage). Each section maps a specific prompt file to an output Markdown file and can define specific LLM parameters or context rules.\n\n**Notebook Decoupling**: Configuration and prompts can reside either in the source repository or within a `nb` workspace. This allows documentation logic and drafting to occur independently of the source code, keeping repositories clean and enabling private iteration before publishing.\n\n**Context-Aware Generation**: The tool utilizes `grove cx` to assemble file-based context from the repository. It combines prompts, the previous documentation iteration, and `cx` codebase context to generate content via `grove llm`.\n\n**Aggregation \u0026 Manifests**: The `aggregate` command scans a workspace for enabled packages, collects their documentation based on status (`draft`, `dev`, `production`), and generates a `manifest.json`. This output drives static site generators (like Astro) for building unified documentation portals."
        },
        {
          "title": "Features",
          "content": "### Generation \u0026 Maintenance\n*   **`docgen generate`**: Generates documentation sections based on the configuration. Supports filtering by specific sections.\n*   **`docgen watch`**: Monitors documentation sources and triggers incremental rebuilds on file changes. Designed for integration with hot-reloading development servers.\n*   **`docgen sync-readme`**: Injects a specific generated documentation section into a `README.md.tpl` file. This ensures the repository README remains in sync with formal documentation.\n\n### Schema Tools\n*   **`docgen schema enrich`**: Parses JSON schemas and uses an LLM to generate descriptions for properties lacking them.\n*   **`docgen schema generate`**: A wrapper that executes `go generate ./...` to trigger code-based schema generation.\n\n### Workflow Management\n*   **`docgen sync`**: Transfers documentation between the `grove-notebook` (drafting environment) and the local repository (version control). Supports `to-repo` and `from-repo` directions.\n*   **`docgen customize`**: Generates a `grove-flow` plan to interactively customize documentation structure using AI agents.\n*   **`docgen logo generate`**: Creates combined SVG assets containing a logo and text, converting text to paths to ensure consistent rendering without external font dependencies."
        },
        {
          "title": "Integrations",
          "content": "*   **`cx`**: Used to generate repository context files based on `.grove/rules`.\n*   **`flow`**: Orchestrates interactive customization plans.\n*   **`nb`**: Resolves workspace locations for storing prompts and drafts outside the source repository."
        }
      ]
    }
  }
}